{"pageProps":{"postData":{"id":"tangram","contentHtml":"<div style=\"text-align:center\">\n  <h1>179 Tangrams</h1>\n  <a href=\"https://twpride.github.io/tangram/\">\n    <h2>\n      Live Site\n    </div>\n  </a>\n</div>\n<p align=\"center\">\n  <video style=\"width:min(480px,100%); margin-left:auto; margin-right:auto\" controls muted autoplay loop src=\"https://howardhwang.s3-us-west-1.amazonaws.com/gamefull.mp4\"></video>\n</p>\n<p>Tangrams is a browser implementation of the classic Chinese puzzle using plain JavaScript(no packages) and the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API\">Canvas API</a>. The puzzle consists of seven polygons tiles, which are put together to form shapes. The objective is to replicate a given pattern using all seven tiles without overlap.</p>\n<h1>Challenges</h1>\n<h2>Puzzle solve state detection</h2>\n<h3>Motivation: timed gameplay</h3>\n<p>A dimension that is unique to this implementation of Tangram is that the player is scored by how quickly he/she can solve a puzzle. A timer automatically starts when the player enters a level and is only stopped whenever the user exits (by hitting pause, or switching tabs) or when the puzzle is solved. This added timing component means that the program would need a quick and cheap way to constantly check whether the puzzle had been solved.</p>\n<h3>Solution: counting pixels on a secondary &#x3C;canvas></h3>\n<p>For the aforementioned task, a raster based overlap detection algorithm was developed. The approach involves painting the silhouette and tiles onto a secondary canvas, making sure the two entities are centered with respect to one another, and then counting the non-overlapping pixels on the silhoutte.</p>\n<p>The screenshot below shows live gameplay with the secondary canvas overlayed on top. As the tiles on the main canvas moves, the secondary canvas is also updated. The green counter is a live reading of sum of total number of non-overlapping silhouette pixels. Notice that when the when the probem solved, the green coutner drops to below 6000, which is the solve threshold, and the timer stops.</p>\n<div style=\"display: flex; justify-content: center; align-item: center\">\n <img width=\"360\" height=\"auto\" src=\"https://raw.githubusercontent.com/twpride/tangram/master/demo/sil_opt.gif\"></img>\n</div>\n<h3>Algorithm details</h3>\n<p>We start out painting the silhouette then the tangram tiles on a secondary canvas that is off-screen. By ensuring that the geometric centers of the silhouette and the tangram tiles align, it follows that there is maximum overlap between the tangram tiles and the silhouette when the puzzle is solved. Conversely, this means that the non-overlapping areas of the silhouette is at a minimum.</p>\n<p>To detect this solved state, we set both the background and the tile to black (rgb(0,0,0)) while the silhouette set to any non-black color which in our case was cyan, most importantly with a red color value of 1, rgb(1,255,255). Since the tangrams shapes are painted after the silhouette, any overlapping areas will be set to black, whereas the non-overlapping areas of the silhouette remain cyan.</p>\n<p>After every tile move, the program sums the red pixel values of all the pixels on the secondary canvas (using <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/getImageData\">CanvasRenderingContext2D.getImageData()</a>). Since we had set the silhouette to have a red color value of 1, the sum is also the number of pixels of silhouette that is non-overlapping. If the non-overlap pixel count is below a certain threshold (empirically determined), we can conclude that the player has solved the puzzle.</p>\n<h2>A custom carousel element</h2>\n<div style=\"display: flex; justify-content: center; align-item: center\">\n  <img width=\"360\" height=\"auto\" src=\"https://raw.githubusercontent.com/twpride/tangram/master/demo/slider_opt.gif\"></img>\n</div>\n<h3>Hover preview</h3>\n<p>As the use hover the mouse over each problem icon in the carousel, the game canvas updates with a preview of the problem and the current state of the tiles in that level. The silhouette for unsolved problems are blurred in the preview to prevent the player from getting a head start before starting the timer.</p>\n<h3>Page snap easing animation</h3>\n<p>To allow for smooth transition between pages, the carousel utilizes a <a href=\"https://github.com/gre/bezier-easing\">Bezier easing function</a> to generate the snapping animation to the nearest page.</p>\n<h3>Integrated heatmap</h3>\n<p>The carousel also functions as a heat map that tracks the player's progress. The heat maps colors each level icon depending on elapsed time and the puzzle solve state. The heatmap is generated by formatting an <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#hsl_colors\">HSL</a> color string with the which becomes an attributes of a SVG <a href=\"https://developer.mozilla.org/en-US/docs/Web/SVG/Element/rect\">&#x3C;rect></a> element.</p>\n<p>The heat map adds a badge-like reward mechanism to the gameplay experience. The user may be motivated to fill up the entire carousel with green boxes :)</p>\n<h2>Collision detection</h2>\n<div style=\"display: flex; justify-content: center; align-item: center\">\n  <img width=\"360\" height=\"auto\" src=\"https://raw.githubusercontent.com/twpride/tangram/master/demo/collision_opt.gif\"></img>\n</div>\n<p>Adding realism to the game play, the program checks for collision between the puzzle tiles. After each tile move, if there is a collision, the penetration amount between the penetrating vertex and the penetrated edge is calculated.</p>\n<p>Before we can calculate the penetration amount, we first need to find all the vertices that have penetrated another polygon by iterating through each vertex polygon combination possible (with some pruning) running the following function.</p>\n<p>Note: All points and vectors in the format of a length 2 array [x-component,y-compoent],</p>\n<div class=\"remark-highlight\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword module\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">toVec</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b</span><span class=\"token punctuation\">)</span> <span class=\"token arrow operator\">=></span> <span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword module\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">cross</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">v<span class=\"token punctuation\">,</span> w</span><span class=\"token punctuation\">)</span> <span class=\"token arrow operator\">=></span> v<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> w<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> v<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> w<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword module\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">insidePoly</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">vertices<span class=\"token punctuation\">,</span> p</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// checks if point p in located inside polygon with def by the vertices argment</span>\n  <span class=\"token comment\">// important!! this assumes vertices are arranged in counter clockwise order</span>\n  <span class=\"token keyword\">let</span> left <span class=\"token operator\">=</span> vertices<span class=\"token punctuation\">[</span>vertices<span class=\"token punctuation\">.</span><span class=\"token property-access\">length</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword control-flow\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&#x3C;</span> vertices<span class=\"token punctuation\">.</span><span class=\"token property-access\">length</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> center <span class=\"token operator\">=</span> vertices<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword control-flow\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">cross</span><span class=\"token punctuation\">(</span><span class=\"token function\">toVec</span><span class=\"token punctuation\">(</span>center<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">toVec</span><span class=\"token punctuation\">(</span>center<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword control-flow\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    left <span class=\"token operator\">=</span> center<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword control-flow\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n</code></pre></div>\n<p>After we identify the penetrating vertice / penetrated polygon pair, we check the penetrating vertex's latest path segment (defined by its last two recorded positions) for intersection with each edge of the penetrated polygon. Knowing the penetrating vertex and penetrated edge, we calculate the the perpendicular component between them. This perpendicular vector is exactly how much the vertex has penetrated the polygon. The code snippet for this procedure is pasted below. Note that <code>calcPenetration()</code> calls <code>findIntersection()</code></p>\n<div class=\"remark-highlight\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword module\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">findIntersection</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">p<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">,</span> q<span class=\"token punctuation\">,</span> s</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/*</span>\n<span class=\"token comment\">    Based on: https://stackoverflow.com/questions/563198/</span>\n<span class=\"token comment\"></span>\n<span class=\"token comment\">    q+s  p+r</span>\n<span class=\"token comment\">      \\/__________ q+u*s</span>\n<span class=\"token comment\">      /\\  </span>\n<span class=\"token comment\">     /  \\</span>\n<span class=\"token comment\">    p    q</span>\n<span class=\"token comment\">    </span>\n<span class=\"token comment\">    u = (q − p) × r / (r × s)</span>\n<span class=\"token comment\">    when r × s = 0, the lines are either colinear or parallel</span>\n<span class=\"token comment\"></span>\n<span class=\"token comment\">    function returns u</span>\n<span class=\"token comment\">    for intersection to exist, 0&#x3C;u&#x3C;1</span>\n<span class=\"token comment\">  */</span>\n  <span class=\"token keyword\">const</span> q_minus_p <span class=\"token operator\">=</span> <span class=\"token function\">toVec</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> r_cross_s <span class=\"token operator\">=</span> <span class=\"token function\">cross</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword control-flow\">if</span> <span class=\"token punctuation\">(</span>r_cross_s <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token keyword control-flow\">return</span> <span class=\"token keyword null nil\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword control-flow\">return</span> <span class=\"token function\">cross</span><span class=\"token punctuation\">(</span>q_minus_p<span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> r_cross_s<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token keyword module\">export</span> <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">dot</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">v<span class=\"token punctuation\">,</span> w</span><span class=\"token punctuation\">)</span> <span class=\"token arrow operator\">=></span> v<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> w<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> v<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> w<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword module\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">calcPenetration</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">sVertices<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">,</span> lastMouseMove</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">/*</span>\n<span class=\"token comment\">    determine if last mouse move caused a state change for point p</span>\n<span class=\"token comment\">    from no penetration to penetration into shape s (represented by sVertices)</span>\n<span class=\"token comment\"></span>\n<span class=\"token comment\">    if such state change occured, return the penetration vector</span>\n<span class=\"token comment\">    if not, this return null</span>\n<span class=\"token comment\">  */</span>\n  <span class=\"token keyword\">let</span> prev <span class=\"token operator\">=</span> sVertices<span class=\"token punctuation\">[</span>sVertices<span class=\"token punctuation\">.</span><span class=\"token property-access\">length</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// scale last mouse move vector by 20%, empirically this has been found to help </span>\n  <span class=\"token comment\">// with interseciton detection sensitivity</span>\n  lastMouseMove <span class=\"token operator\">=</span> lastMouseMove<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">ele</span> <span class=\"token arrow operator\">=></span> ele <span class=\"token operator\">*</span> <span class=\"token number\">1.2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// iterate through each polygon edge, return if penetration is encountered</span>\n  <span class=\"token keyword control-flow\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> k <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> k <span class=\"token operator\">&#x3C;</span> sVertices<span class=\"token punctuation\">.</span><span class=\"token property-access\">length</span><span class=\"token punctuation\">;</span> k<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> currVertex <span class=\"token operator\">=</span> sVertices<span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> edgeVec <span class=\"token operator\">=</span> <span class=\"token function\">toVec</span><span class=\"token punctuation\">(</span>currVertex<span class=\"token punctuation\">,</span> prev<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// vector respresenting current polygon edge</span>\n    <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token function\">findIntersection</span><span class=\"token punctuation\">(</span>currVertex<span class=\"token punctuation\">,</span> edgeVec<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">,</span> lastMouseMove<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword control-flow\">if</span> <span class=\"token punctuation\">(</span>res\n      <span class=\"token operator\">&#x26;&#x26;</span> res <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token comment\">// res==0, when p started on on the polygon edge</span>\n      <span class=\"token operator\">&#x26;&#x26;</span> res <span class=\"token operator\">&#x3C;</span> <span class=\"token number\">1</span> <span class=\"token comment\">// res==1, when p is on polygon edge after mouse move</span>\n    <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// point indeed penetrated the current polygon edge</span>\n      <span class=\"token comment\">// calculate and return perpendicular component between p and the polygon edge</span>\n      <span class=\"token keyword\">const</span> p_currVertex_vec <span class=\"token operator\">=</span> <span class=\"token function\">toVec</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> currVertex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//</span>\n      <span class=\"token keyword\">const</span> precalc <span class=\"token operator\">=</span> <span class=\"token function\">dot</span><span class=\"token punctuation\">(</span>p_currVertex_vec<span class=\"token punctuation\">,</span> edgeVec<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span>edgeVec<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">**</span> <span class=\"token number\">2</span> <span class=\"token operator\">+</span> edgeVec<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">**</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword control-flow\">return</span> p_currVertex_vec<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">ele<span class=\"token punctuation\">,</span> idx</span><span class=\"token punctuation\">)</span> <span class=\"token arrow operator\">=></span> ele <span class=\"token operator\">-</span> precalc <span class=\"token operator\">*</span> edgeVec<span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    prev <span class=\"token operator\">=</span> currVertex<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword control-flow\">return</span> <span class=\"token keyword null nil\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>Knowing this penetration vector, the moving tile is then shifted back by the this exact amount, ensuring that the tiles are just touching, but not intersecting</p>\n<h2>Puzzle generation</h2>\n<p>Instead of generating the problem manually, examples of Tangram problems found online were leveraged. The 179 puzzles in this game was taken from a <a href=\"https://web.archive.org/web/20200203050759/https://www.cs.brandeis.edu/~storer/JimPuzzles/ZPAGES/zzzRichter08-AnchorPuzzle.html\">puzzle booklet</a> first published in 1890 by the Richter Company of Germany in 1890. The problems were extracted from scanned images of the puzzle booklet with a <a href=\"https://github.com/twpride/tangram/blob/master/scratch/process179.py\">python script</a> using OpenCv's <code>findContours()</code>.</p>\n<h1>Features to add</h1>\n<ul>\n<li>User generated levels</li>\n<li>Public high score leader board</li>\n</ul>\n","title":"179 Tangrams","date":"2020-01-05","preview":"/media/tangram_thumb.png","bgColor":null,"blurb":"179 Tangrams is a browser implementation of the classic Chinese puzzle. Key features include collision detection and puzzle solve detection.","tags":["portfolio","game","canvas","another"]}},"__N_SSG":true}